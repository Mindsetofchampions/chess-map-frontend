/*
  # Master Admin System Complete Setup

  1. New Tables
    - Enhanced `user_roles` table with role assignment tracking
    - `platform_balance` table for system coin management  
    - `platform_ledger` table for transaction tracking
  2. Security
    - RLS policies for all tables with role-based access
    - SECURITY DEFINER functions for privileged operations
    - Proper access control for master_admin functions
  3. Performance
    - Optimized indexes for quest querying
    - Admin approval queue view for efficient dashboard queries
  4. Helper Functions
    - User role management and platform balance operations
    - Demo data seeding for development/testing
*/

-- Enable necessary extensions
create extension if not exists "uuid-ossp";

-- Create user_role enum if not exists
do $plpgsql$
begin
  if not exists (
    select 1 from pg_type t
    join pg_namespace n on n.oid = t.typnamespace
    where n.nspname = 'public' and t.typname = 'user_role'
  ) then
    create type public.user_role as enum ('master_admin', 'org_admin', 'staff', 'student');
  end if;
end
$plpgsql$;

-- Create quest_status enum if not exists  
do $plpgsql$
begin
  if not exists (
    select 1 from pg_type t
    join pg_namespace n on n.oid = t.typnamespace
    where n.nspname = 'public' and t.typname = 'quest_status'
  ) then
    create type public.quest_status as enum ('draft', 'submitted', 'approved', 'rejected', 'archived');
  end if;
end
$plpgsql$;

-- Enhanced user_roles table
create table if not exists public.user_roles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role user_role not null default 'student',
  assigned_by uuid references auth.users(id) on delete set null,
  assigned_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- Platform balance management
create table if not exists public.platform_balance (
  id integer primary key default 1,
  coins bigint not null default 0 check (coins >= 0),
  updated_at timestamp with time zone default now()
);

-- Platform transaction ledger
-- Ensure platform_ledger has metadata column before any inserts
ALTER TABLE IF EXISTS public.platform_ledger
  ADD COLUMN IF NOT EXISTS metadata jsonb DEFAULT '{}'::jsonb;
create table if not exists public.platform_ledger (
  id bigint primary key generated by default as identity,
  direction text not null check (direction in ('DEBIT', 'CREDIT')),
  amount_coins bigint not null check (amount_coins > 0),
  reason text not null,
  quest_id uuid references public.quests(id) on delete set null,
  created_by uuid references auth.users(id) on delete set null,
  created_at timestamp with time zone default now()
);

-- Ensure quests table has proper status constraint
do $plpgsql$
begin
  if not exists (
    select 1 from information_schema.table_constraints
    where table_schema = 'public' and table_name = 'quests' 
    and constraint_name like '%status%check%'
  ) then
    alter table public.quests 
    add constraint quests_status_check 
    check (status in ('draft', 'submitted', 'approved', 'rejected', 'archived'));
  end if;
end
$plpgsql$;

-- Performance index for quest queries
create index if not exists idx_quests_status_created_at 
on public.quests(status, created_at desc);

-- Admin approval queue view
create or replace view public.admin_approval_queue_vw as
select
  q.id,
  q.title,
  q.reward_coins,
  q.status,
  q.created_at,
  q.created_by,
  u.email as creator_email,
  round(extract(epoch from (now() - q.created_at))/60.0)::int as age_minutes
from public.quests q
join auth.users u on u.id = q.created_by
where q.status = 'submitted';

-- Helper function to check if user is master admin
create or replace function public.is_master_admin_check()
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  user_role_val text;
begin
  select role into user_role_val 
  from public.user_roles 
  where user_id = auth.uid();
  
  return coalesce(user_role_val = 'master_admin', false);
end;
$$;

-- Secure quest approval function
drop function if exists public.approve_quest(uuid);
drop function if exists public.approve_quest(uuid);
create or replace function public.approve_quest(p_quest_id uuid)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  quest_rec record;
  platform_coins bigint;
  result json;
begin
  -- Verify master admin access
  if not is_master_admin_check() then
    return json_build_object(
      'success', false,
      'error', 'FORBIDDEN',
      'message', 'Only master administrators can approve quests'
    );
  end if;
  
  -- Get quest details
  select * into quest_rec from public.quests where id = p_quest_id;
  
  if not found then
    return json_build_object(
      'success', false,
      'error', 'NOT_FOUND',
      'message', 'Quest not found'
    );
  end if;
  
  if quest_rec.status != 'submitted' then
    return json_build_object(
      'success', false,
      'error', 'INVALID_STATE',
      'message', 'Quest status is ' || quest_rec.status || ' but must be submitted'
    );
  end if;
  
  -- Check platform balance
  select coins into platform_coins from public.platform_balance where id = 1;
  
  if platform_coins < quest_rec.reward_coins then
    return json_build_object(
      'success', false,
      'error', 'INSUFFICIENT_FUNDS',
      'message', 'Platform has ' || platform_coins || ' coins but quest requires ' || quest_rec.reward_coins
    );
  end if;
  
  -- Perform approval transaction
  begin
    -- Deduct from platform balance
    update public.platform_balance 
    set coins = coins - quest_rec.reward_coins,
        updated_at = now()
    where id = 1;
    
    -- Record platform ledger entry
    insert into public.platform_ledger (direction, amount_coins, reason, quest_id, created_by)
    values ('DEBIT', quest_rec.reward_coins, 'Quest approval funding', p_quest_id, auth.uid());
    
    -- Update quest status
    update public.quests 
    set status = 'approved',
        approved_at = now(),
        approved_by = auth.uid()
    where id = p_quest_id;
    
    result = json_build_object(
      'success', true,
      'quest_id', p_quest_id,
      'reward_coins', quest_rec.reward_coins,
      'new_platform_balance', platform_coins - quest_rec.reward_coins
    );
    
    return result;
  exception when others then
    return json_build_object(
      'success', false,
      'error', 'UNKNOWN',
      'message', 'Unexpected error during approval: ' || sqlerrm
    );
  end;
end;
$$;

-- Secure quest rejection function
drop function if exists public.reject_quest(uuid, text);
create or replace function public.reject_quest(p_quest_id uuid, p_reason text)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  quest_rec record;
begin
  -- Verify master admin access
  if not is_master_admin_check() then
    return json_build_object(
      'success', false,
      'error', 'FORBIDDEN',
      'message', 'Only master administrators can reject quests'
    );
  end if;
  
  -- Get quest details
  select * into quest_rec from public.quests where id = p_quest_id;
  
  if not found then
    return json_build_object(
      'success', false,
      'error', 'NOT_FOUND',
      'message', 'Quest not found'
    );
  end if;
  
  if quest_rec.status != 'submitted' then
    return json_build_object(
      'success', false,
      'error', 'INVALID_STATE',
      'message', 'Quest status is ' || quest_rec.status || ' but must be submitted'
    );
  end if;
  
  -- Perform rejection
  begin
    update public.quests 
    set status = 'rejected',
        rejection_reason = p_reason,
        rejected_at = now(),
        rejected_by = auth.uid()
    where id = p_quest_id;
    
    return json_build_object(
      'success', true,
      'quest_id', p_quest_id,
      'reason', p_reason
    );
  exception when others then
    return json_build_object(
      'success', false,
      'error', 'UNKNOWN',
      'message', 'Unexpected error during rejection: ' || sqlerrm
    );
  end;
end;
$$;

-- Helper function to set user role (master_admin only)
drop function if exists public.set_user_role(text, text);
create or replace function public.set_user_role(p_email text, p_role text)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  target_user_id uuid;
  current_role text;
begin
  -- Verify master admin access
  if not is_master_admin_check() then
    return json_build_object(
      'success', false,
      'error', 'FORBIDDEN',
      'message', 'Only master administrators can set user roles'
    );
  end if;
  
  -- Validate role
    if p_role not in ('student', 'org_admin', 'staff', 'master_admin') then
    return json_build_object(
      'success', false,
      'error', 'INVALID_INPUT',
      'message', 'Invalid role: ' || p_role
    );
  end if;
  
  -- Get target user ID
  select id into target_user_id from auth.users where email = p_email;
  
  if not found then
    return json_build_object(
      'success', false,
      'error', 'NOT_FOUND',
      'message', 'User not found: ' || p_email
    );
  end if;
  
  -- Get current role to prevent master_admin demotion
  select role into current_role from public.user_roles where user_id = target_user_id;
  
  if current_role = 'master_admin' and p_role != 'master_admin' then
    return json_build_object(
      'success', false,
      'error', 'FORBIDDEN',
      'message', 'Cannot demote master administrators'
    );
  end if;
  
  -- Set the role
  insert into public.user_roles (user_id, role, assigned_by)
  values (target_user_id, p_role::user_role, auth.uid())
  on conflict (user_id) do update set
    role = excluded.role,
    assigned_by = excluded.assigned_by,
    updated_at = now();
    
  return json_build_object(
    'success', true,
    'user_id', target_user_id,
    'email', p_email,
    'role', p_role
  );
end;
$$;

-- Helper function to top up platform balance (master_admin only)
-- Ensure any existing function with this signature is removed to allow recreation
drop function if exists public.top_up_platform_balance(bigint, text);
 
create or replace function public.top_up_platform_balance(p_amount bigint, p_reason text)
returns json
language plpgsql
security definer
set search_path = public
as $$
begin
  -- Verify master admin access
  if not is_master_admin_check() then
    return json_build_object(
      'success', false,
      'error', 'FORBIDDEN',
      'message', 'Only master administrators can manage platform balance'
    );
  end if;
  
  if p_amount <= 0 then
    return json_build_object(
      'success', false,
      'error', 'INVALID_INPUT',
      'message', 'Top-up amount must be positive'
    );
  end if;
  
  -- Add to platform balance
  update public.platform_balance 
  set coins = coins + p_amount,
      updated_at = now()
  where id = 1;
  
  -- Record ledger entry
  insert into public.platform_ledger (direction, amount_coins, reason, created_by)
  values ('CREDIT', p_amount, p_reason, auth.uid());
  
  return json_build_object(
    'success', true,
    'amount', p_amount,
    'reason', p_reason
  );
end;
$$;

-- RLS Policies for user_roles
alter table public.user_roles enable row level security;

-- Users can read their own role
drop policy if exists "user_roles_select_own" on public.user_roles;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='user_roles' and policyname='user_roles_select_own') then
    execute 'drop policy "user_roles_select_own" on public.user_roles';
  end if;
end $plpgsql$;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='user_roles' and policyname='user_roles_select_own') then
    execute 'drop policy "user_roles_select_own" on public.user_roles';
  end if;
end $plpgsql$;
create policy "user_roles_select_own" on public.user_roles 
for select using (auth.uid() = user_id);

-- Master admins can read all roles
drop policy if exists "user_roles_select_master" on public.user_roles;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='user_roles' and policyname='user_roles_select_master') then
    execute 'drop policy "user_roles_select_master" on public.user_roles';
  end if;
end $plpgsql$;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='user_roles' and policyname='user_roles_select_master') then
    execute 'drop policy "user_roles_select_master" on public.user_roles';
  end if;
end $plpgsql$;
create policy "user_roles_select_master" on public.user_roles 
for select using (
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role = 'master_admin'
  )
);

-- Only master admins can INSERT/UPDATE/DELETE roles
drop policy if exists "user_roles_master_write" on public.user_roles;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='user_roles' and policyname='user_roles_master_write') then
    execute 'drop policy "user_roles_master_write" on public.user_roles';
  end if;
end $plpgsql$;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='user_roles' and policyname='user_roles_master_write') then
    execute 'drop policy "user_roles_master_write" on public.user_roles';
  end if;
end $plpgsql$;
create policy "user_roles_master_write" on public.user_roles 
for all using (
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role = 'master_admin'
  )
)
with check (
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role = 'master_admin'
  )
);

-- RLS Policies for platform_balance
alter table public.platform_balance enable row level security;

drop policy if exists "platform_balance_master_only" on public.platform_balance;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='platform_balance' and policyname='platform_balance_master_only') then
    execute 'drop policy "platform_balance_master_only" on public.platform_balance';
  end if;
end $plpgsql$;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='platform_balance' and policyname='platform_balance_master_only') then
    execute 'drop policy "platform_balance_master_only" on public.platform_balance';
  end if;
end $plpgsql$;
create policy "platform_balance_master_only" on public.platform_balance 
for all using (
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role = 'master_admin'
  )
)
with check (
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role = 'master_admin'
  )
);

-- RLS Policies for platform_ledger
alter table public.platform_ledger enable row level security;

drop policy if exists "platform_ledger_master_only" on public.platform_ledger;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='platform_ledger' and policyname='platform_ledger_master_only') then
    execute 'drop policy "platform_ledger_master_only" on public.platform_ledger';
  end if;
end $plpgsql$;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='platform_ledger' and policyname='platform_ledger_master_only') then
    execute 'drop policy "platform_ledger_master_only" on public.platform_ledger';
  end if;
end $plpgsql$;
create policy "platform_ledger_master_only" on public.platform_ledger 
for all using (
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role = 'master_admin'
  )
)
with check (
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role = 'master_admin'
  )
);

-- Enhance existing quests RLS policies
drop policy if exists "quests_select_approved" on public.quests;
drop policy if exists "quests_select_approved_or_admin" on public.quests;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='quests' and policyname='quests_select_approved_or_admin') then
    execute 'drop policy "quests_select_approved_or_admin" on public.quests';
  end if;
end $plpgsql$;
do $plpgsql$ begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='quests' and policyname='quests_select_approved_or_admin') then
    execute 'drop policy "quests_select_approved_or_admin" on public.quests';
  end if;
end $plpgsql$;
create policy "quests_select_approved_or_admin" on public.quests 
for select using (
  status = 'approved' or 
  exists (
    select 1 from public.profiles p 
    where p.user_id = auth.uid() and p.role in ('master_admin', 'org_admin', 'staff')
  ) or
  created_by = auth.uid()
);

-- Revoke public access to sensitive functions
revoke all on function public.approve_quest(uuid) from public;
revoke all on function public.reject_quest(uuid, text) from public;
revoke all on function public.set_user_role(text, text) from public;
revoke all on function public.top_up_platform_balance(bigint, text) from public;

-- Grant execute to authenticated users (RLS will handle authorization)
grant execute on function public.approve_quest(uuid) to authenticated;
grant execute on function public.reject_quest(uuid, text) to authenticated;
grant execute on function public.set_user_role(text, text) to authenticated;
grant execute on function public.top_up_platform_balance(bigint, text) to authenticated;

-- Initialize platform balance
insert into public.platform_balance (id, coins)
values (1, 10000)
on conflict (id) do nothing;

-- Seed initial demo quests (optional)
do $plpgsql$
begin
  if not exists (select 1 from public.quests where title like 'Demo%') then
    insert into public.quests (title, description, status, reward_coins, qtype, config) values
    ('Demo Character Quest', 'Learn about character development with Hootie', 'approved', 50, 'mcq', '{"options":[{"id":"a","text":"Honesty"},{"id":"b","text":"Dishonesty"}],"correct":"a"}'),
    ('Demo Health Quest', 'Wellness challenge with Brenda', 'approved', 75, 'mcq', '{"options":[{"id":"a","text":"Exercise daily"},{"id":"b","text":"Stay sedentary"}],"correct":"a"}'),
    ('Demo Pending Quest', 'Test quest for approval workflow', 'submitted', 100, 'mcq', '{"options":[{"id":"a","text":"Yes"},{"id":"b","text":"No"}],"correct":"a"}');
  end if;
end
$plpgsql$;

-- Update timestamp trigger for user_roles
create or replace function public.update_user_roles_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_user_roles_updated_at on public.user_roles;
create trigger trg_user_roles_updated_at
  before update on public.user_roles
  for each row execute function public.update_user_roles_updated_at();